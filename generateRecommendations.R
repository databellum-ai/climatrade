#========================================================
# Function to generate recommendations for n "examplesToGenerate" dates
# https://bookdown.org/singh_pratap_tejendra/intro_time_series_r/neural-networks-in-time-series-analysis.html
generateRecommendations <- function(sampleDates, examplesToGenerate, lagToApply, datesRecommendations) {
  recommendationsConsolidated <- data.frame()  # initialize
  for (i in sampleDates) {
    # build dataset of all past observations (time series) until given date
    print(paste0("Processing date: ", as_date(i)))
    lastDateAvailable <- as_date(i) # last date available for training observations
    firstDateToForecast <- lastDateAvailable + 1
    lastDateToForecast <- firstDateToForecast + daysToForecast - 1
    # add a lagged columns to dataset:
    df_planetMood_1 <- df_planetMood %>% mutate(
      VIX_n = lag(VIX, n=lagToApply), 
      VVIX_n = lag(VVIX, n=lagToApply), 
      VIX3M_n = lag(VIX3M, n=lagToApply), 
      VIXNsdq_n = lag(VIXNsdq, n=lagToApply), 
      GoldVlty_n = lag(GoldVlty, n=lagToApply), 
      DAI3_n = lag(DAI3, n=lagToApply), 
      CCI_n = lag(CCI, n=lagToApply)
    ) %>% 
      filter(!is.na(VIX_n)) # we remove lines with NAs generated by lagging
    # prepare training dataset (past)
    df_planetMood_train <- df_planetMood_1 %>% 
      select(date, VIX, laggedVbles, calendarVbles) %>% 
      filter(date >= "2017-01-01" & date <= lastDateAvailable)
    # calculate regressors (future)
    futureData <- df_planetMood_1 %>% 
      select(date, laggedVbles, calendarVbles) %>% 
      filter(date >= firstDateToForecast & date <= lastDateToForecast)
    # ----
    # forecast obtained data into the short future
    yTrain <- df_planetMood_train$VIX
    xTrain <- df_planetMood_train[,3:13]  # remove date and VIX
    fit6 <- nnetar(ts(yTrain, frequency = frequencyNN), xreg = xTrain)
    # forecast
    xFuture <- futureData[,2:12] # remove date
    fc6 <- forecast(fit6, h = daysToForecast, xreg = xFuture, PI = F)
    # store
    VIX_forecasted <- fc6$mean
    # calculate accuracy details
    closingRef <- df_planetMood_1 %>% filter(date == lastDateAvailable) %>% select(date, VIX)
    real <- df_planetMood_1 %>% filter(between(date,firstDateToForecast,lastDateToForecast)) %>% select(date,VIX_real=VIX)
    recommendationsForDate_NN <- 
      cbind(date_txn=closingRef$date, VIX_txn=closingRef$VIX, real, VIX_forecasted = as.numeric(VIX_forecasted)) %>% 
      mutate(
        realChangePercent = 100*(VIX_real - VIX_txn)/VIX_txn, 
        predChangePercent = as.numeric(100*(VIX_forecasted - VIX_txn)/VIX_txn), 
        txnLength = date - date_txn, 
        horizon = daysToForecast, 
        action = as.character(ifelse(VIX_forecasted > VIX_txn, "BUY", "SELL")), 
        earningsPercent = as.numeric(
          ifelse
          (
            (realChangePercent * predChangePercent) > 0, 
            abs(realChangePercent), 
            -1*abs(realChangePercent)
          )
        ),       
        success = as.logical(earningsPercent >= 0)
      )
    # show  
    matplot(recommendationsForDate_NN[,c(2, 4:5)], type = "b", pch=1, col = c(1, 3,2))
    legend("bottomleft", legend = c("VIX_txn", "VIX_real", "VIX_forecasted"), col= c(1, 3,2), pch=1)
    recommendationsConsolidated <- rbind(recommendationsConsolidated, recommendationsForDate_NN)
  }
  print("Process finished. Recommended actions generated based in all past values until run date")
  # consolidate new generated observations for history
  saveRDS((rbind(readRDS("data/recommendationsNN_all.RDS"), recommendationsConsolidated)), "data/recommendationsNN_all.RDS")
  return(recommendationsConsolidated)
}