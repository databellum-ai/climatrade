# JES: !en NN+xReg: probar "daysToForecast" = 3 | = 10
# JES: !en NN+xReg: probar "frequency" <> 7
# JES: !en NN+xReg: usar log() y scale() para refinar
# JES: !descartar ARIMA, prophet, VAR
# JES: !refinar más vblesPlanetMood (movingAverage/diff/log/smooth)
# JES: !en NN+xReg:probar VAR (Haydn + Tajendra) para forecast de regressors (*_n) (actuales y vblesPlanetMood)
# JES: en NN+xReg: jugar con más parámetros de nnetar y de forecast
# JES: usar regresión para optimizar criterio BUY/SELL en "accuracies_all" (previamente hacer cálculo masivo >= 100 fechas)
# JES: crear shinnyApp


#========================================================#
# Forecasting: Principles and Practice (3rd ed)
# Rob J Hyndman and George Athanasopoulos
# 
# https://otexts.com/fpp3/
#========================================================#
  
source("10_initialize.R")

# install.packages("fpp3")
# install.packages("GGally")
# install.packages("tseries")
# install.packages("astsa")
# install.packages("fable.prophet")

library(fpp3)
library(GGally)

library(tidyverse)

#========================================================
# Prepare data
#========================================================

# PlanetMood dataset
df_planetMood <- readRDS("data/df_planetMood.rds") %>% arrange(date) %>% 
  mutate(VIX = VIX+30, Year = year(date)) # Dataset ready for analysis 
allVbles <- names(df_planetMood)
# allVbles <- c("VIX", "Gold", "SP500", "VVIX", "VIX3M", "VIXNsdq", "GoldVlty", "VIX_HLvol", "VVIX_HLvol", "VIX3M_HLvol", "VIXNsdq_HLvol", "GoldVlty_HLvol", "Gold_HLvol", "SP500_HLvol", "NewsTone", "Goldstein", "IAI", "DAI1", "DAI2", "DAI3", "BCI", "CCI", "CLI", "Flights", "Tempo", "Energy", "Danceability", "MoonPhase", "WkDay", "YrWeek", "Year")
selectedVbles <- c("VIX", "VVIX", "VIX3M", "VIXNsdq", "GoldVlty", "DAI3", "CCI")
laggedVbles <- paste0(selectedVbles,"_n")
calendarVbles <- c("MoonPhase", "WkDay", "YrWeek", "Year")
df_planetMood_1 <- df_planetMood %>% 
  select(date, 
         selectedVbles, 
         calendarVbles)

# dates and intervals:
lastDateAvailable <- as_date("2022-06-01")
firstDateToForecast <- lastDateAvailable + 1
daysToForecast <- 7
lagToApply <- daysToForecast
lastDateToForecast <- firstDateToForecast + daysToForecast - 1

# create a lagged dataset with added lagged columns:
df_planetMood_1 <- df_planetMood %>% mutate(
  VIX_n = lag(VIX, n=lagToApply), 
  VVIX_n = lag(VVIX, n=lagToApply), 
  VIX3M_n = lag(VIX3M, n=lagToApply), 
  VIXNsdq_n = lag(VIXNsdq, n=lagToApply), 
  GoldVlty_n = lag(GoldVlty, n=lagToApply), 
  DAI3_n = lag(DAI3, n=lagToApply), 
  CCI_n = lag(CCI, n=lagToApply)
) %>% 
  filter(!is.na(VIX_n)) # we remove lines with NAs generated by lagging

# other datasets for analysis:
df_planetMoodActual_train <- df_planetMood_1 %>% 
  select(date, VIX, selectedVbles, calendarVbles) %>% 
  filter(date >= "2017-01-01" & date <= lastDateAvailable)
df_planetMood_train <- df_planetMood_1 %>% 
  select(date, VIX, laggedVbles, calendarVbles) %>% 
  filter(date >= "2017-01-01" & date <= lastDateAvailable)
futureData <- df_planetMood_1 %>% 
  select(date, laggedVbles, calendarVbles) %>% 
  filter(date >= firstDateToForecast & date <= lastDateToForecast)
# convert datasets into ts() objects
df_planetMood_ts <- as_tsibble(df_planetMood_1, index = date)  # convert to tsibble (time serie)
df_planetMoodActual_train_ts <- as_tsibble(df_planetMoodActual_train, index = date)
df_planetMood_train_ts <- as_tsibble(df_planetMood_train, index = date)
futureData_ts <- as_tsibble(futureData, index = date)

# Available datasets
head(df_planetMood_ts)
head(df_planetMood_train_ts)
head(df_planetMoodActual_train_ts)
head(futureData)


#========================================================
#========================================================
# FUNCTIONS
#========================================================
#========================================================
# function calculate "PlanetMood" Accuracy for our prediction
calculateAccuracyDataframe_pm <- function(VIX_forecasted) {
  closingRef <- df_planetMood_1 %>% filter(date == lastDateAvailable) %>% select(date, VIX)
  real <- df_planetMood_1 %>% filter(between(date,firstDateToForecast,lastDateToForecast)) %>% select(date,VIX_real=VIX)
  accuracy_pm <- 
    cbind(date_txn=closingRef$date, VIX_txn=closingRef$VIX, real, as.numeric(VIX_forecasted)) %>% 
    mutate(
      action = as.character(ifelse(VIX_forecasted > VIX_txn, "BUY", "SELL")), 
      realChangePercent = 100*(VIX_real - VIX_txn)/VIX_txn, 
      predChangePercent = as.numeric(100*(VIX_forecasted - VIX_txn)/VIX_txn), 
      success = as.logical((realChangePercent * predChangePercent) > 0),
      txnLength = date - date_txn, 
      earningsPercent = as.numeric(ifelse(success, abs(realChangePercent), -1*abs(realChangePercent)))
    )
  return(accuracy_pm)
}


#========================================================
#========================================================
# EDA
#========================================================
#========================================================

# Draw mosaic all variables n x m
mosaicVbles <- allVbles[!(allVbles %in% c("date", calendarVbles))]

n <- length(mosaicVbles)
# we calculate how many rows and column are needed to represent all variables as squared as possible
r <- c <- round(sqrt(n),0)  # try to use squared matrix for representation of all variables
if (r*c < n) {c <- c+1}  # if not enough, we try one more column
if (r*c < n) {r <- r+1}  # if still not enough, we add one row
par(mfrow=c(r,c), mar=c(5,3,3,3))
for(i in 1:n) {
  matplot(df_planetMood[,mosaicVbles][,i], axes=FALSE,
          type=c('l'), col = c('blue'), 
          main = names(df_planetMood[,mosaicVbles])[i])
  axis(2) # show y axis
  axis(1, at=seq_along(1:nrow(df_planetMood)),
       labels=df_planetMood$date, las=2)
}

# Draw 1:1 comparison in two different axis
# Function to draw
chartTwoAxis <- function(x, y1, y2, y1_name, y2_name) {
  par(mfrow=c(1,1))
  par(mar=c(5,5,5,5)+0.1, las=1)
  plot.new()
  plot.window(xlim=range(x), ylim=range(y1))
  lines(x, y1, col="red", pch=19, lwd=1)
  axis(1, col.axis="blue")
  axis(2, col.axis="red")
  box()
  plot.window(xlim=range(x), ylim=range(y2))
  lines(x, y2, col="limegreen", pch=19, lwd=1)
  axis(4, col.axis="limegreen")
  title(paste("1:1 compared history", y1_name, "vs", y2_name), adj=0)
  mtext(y2_name, side = 4, las=3, line=3, col="limegreen")
  mtext(y1_name, side = 2, las=3, line=3, col="red") }
# Call the function to draw
chartTwoAxis(df_planetMood$date, df_planetMood$VIX, df_planetMood$VVIX, "VIX", "VVIX_n")

# Draw pairs of correlations in date groups
library(xts)    
tmpData <- df_planetMood[,c("date", selectedVbles)]
tmpData <- as.xts(tmpData[, -1], order.by = tmpData$date)
pairs(coredata(tmpData), 
      lower.panel = NULL,
      col = df_planetMood$Year,
      pch = 18,
      main = "Pairs correlations colorred by years")

# Draw pairs of correlations shown correlation and distribution
as_tsibble(df_planetMood, index = date) %>% GGally::ggpairs(columns = selectedVbles)

# variable:variable lagged correlations
library(tseries)
# see correlation of past values (represented by lag "-n") of variable x respect to variable y :
ccf(x = df_planetMood$VIXNsdq, y = df_planetMood$VIX, lag=90, plot=FALSE, xlim=range(-90,-1))
ccf(x = df_planetMood$VIXNsdq, y = df_planetMood$VIX, lag=90, plot=TRUE, xlim=range(-90,-1))
# Draw variable correlation with its lagged values
library(astsa)
lag2.plot(df_planetMood$VIXNsdq, df_planetMood$VIX, 
          max.lag = 15, 
          smooth = TRUE, 
          cex=0.2, pch=19, col=5, bgl='transparent', lwl=2, gg=T, box.col=gray(1))


#========================================================
#========================================================
# Modelling
#========================================================
#========================================================
# ------------------------------------
# 12.2 ARIMA vs ETL vs prophet
# Other ARIMA links:
# https://www.educba.com/arima-model-in-r/
# https://rpubs.com/riazakhan94/arima_with_example
# =========
# REGRESSION + ARIMA&Fourier:
fit <- df_planetMood_train_ts %>%
  model(
    ARIMA(VIX ~ PDQ(0, 0, 0) + pdq(d = 0) +
            VIX_n + VVIX_n + VIX3M_n + VIXNsdq_n + GoldVlty_n + DAI3_n + MoonPhase + WkDay + YrWeek + Year + 
            fourier(period = "week", K = 3) +
            fourier(period = "month", K = 5) +
            fourier(period = "year", K = 3))
  )
fit %>% gg_tsresiduals()
fit %>% accuracy
fc <- fit %>% forecast(new_data = futureData_ts)
fc %>% autoplot(df_planetMood_ts %>% tail(100)) + labs(x = "Date", y = "VIX")
accuracy_pm_ARIMA_regrss <- calculateAccuracyDataframe_pm(fc$.mean)
accuracy_pm_ARIMA_regrss
sum(accuracy_pm_ARIMA_regrss$earningsPercent)
matplot(accuracy_pm_ARIMA_regrss[,c(2, 4:5)], type = "b", pch=1, col = c(1, 3,2))
legend("bottomleft", legend = c("VIX_txn", "VIX_real", "VIX_forecasted"), col= c(1, 3,2), pch=1)
# =========
# ARIMA with covariates
# https://stackoverflow.com/questions/51873358/forecasting-from-regression-with-auto-arima-and-defining-xreg
covariates <- c("VVIX_n", "VIX3M_n", "VIXNsdq_n", "VIX_n", "GoldVlty_n", "DAI3_n", "MoonPhase", "WkDay", "Year") 
# covariates <- c("VVIX_n", "VIX3M_n", "VIXNsdq_n", "VIX_n", "GoldVlty_n", "DAI3_n", "CCI_n", "MoonPhase", "WkDay", "YrWeek")
# exp((log(df_planetMood_train[,covariates])))
fit1 <- auto.arima(df_planetMood_train[,"VIX"], xreg = as.matrix(df_planetMood_train[,covariates]))
summary(fit1)
fit1$aic
fc1 <- forecast(fit1, xreg = as.matrix(futureData[, covariates]))
autoplot(fc1)
VIX_forecasted <- fc1$mean
accuracy_pm_ARIMA_xreg <- calculateAccuracyDataframe_pm(VIX_forecasted)
accuracy_pm_ARIMA_xreg
sum(accuracy_pm_ARIMA_xreg$earningsPercent)
matplot(accuracy_pm_ARIMA_xreg[,c(2, 4:5)], type = "b", pch=1, col = c(1, 3,2))
legend("bottomleft", legend = c("VIX_txn", "VIX_real", "VIX_forecasted"), col= c(1, 3,2), pch=1)

# =========
# REGRESSION + prophet:
library(fable.prophet)
fit2 <- df_planetMood_train_ts %>%
  model(prophet(VIX ~ VIX_n +
                  VVIX_n + VIX3M_n + VIXNsdq_n + GoldVlty_n + DAI3_n + CCI_n + 
                  MoonPhase + WkDay + YrWeek + Year +
                                   season(period = "week", order = 5) +
                                   season(period = "month", order = 4) +
                                   season(period = "year", order = 3))
  )
fit2 %>% components() %>% autoplot()
fit2 %>% gg_tsresiduals()
fit2 %>% accuracy
fc2 <- fit2 %>% forecast(new_data = futureData_ts)
fc2 %>% autoplot(df_planetMood_ts %>% tail(100)) + labs(x = "Date", y = "VIX")
accuracy_pm_Prophet_regrss <- calculateAccuracyDataframe_pm(fc2$.mean)
accuracy_pm_Prophet_regrss
sum(accuracy_pm_Prophet_regrss$earningsPercent)
matplot(accuracy_pm_Prophet_regrss[,c(2, 4:5)], type = "b", pch=1, col = c(1, 3,2))
legend("bottomleft", legend = c("VIX_txn", "VIX_real", "VIX_forecasted"), col= c(1, 3,2), pch=1)

# ------------------------------
# 12.3 VAR
fit3 <- (df_planetMoodActual_train_ts) %>%
  model(
    aicc = VAR(vars(VIX, VVIX, VIX3M, VIXNsdq, GoldVlty, DAI3, CCI, MoonPhase, WkDay, YrWeek)),
    bic = VAR(vars(VIX, VVIX, VIX3M, VIXNsdq, GoldVlty, DAI3, CCI, MoonPhase, WkDay, YrWeek), ic = "bic")
  )
fit3
glance(fit3)
fit3 %>%
  augment() %>%
  ACF(.innov) %>%
  autoplot()
fc3 <- fit3 %>% select(aicc) %>% forecast(h = daysToForecast) 
fc3 %>% autoplot(df_planetMood_ts %>% tail(100))
accuracy_pm_VAR <- calculateAccuracyDataframe_pm(fc3$.mean[,1])
accuracy_pm_VAR
sum(accuracy_pm_VAR$earningsPercent)
matplot(accuracy_pm_VAR[,c(2, 4:5)], type = "b", pch=1, col = c(1, 3,2))
legend("bottomleft", legend = c("VIX_txn", "VIX_real", "VIX_forecasted"), col= c(1, 3,2), pch=1)

# ------------------------------
# 12.4 NEURAL NETWORKS
fit4 <- df_planetMoodActual_train_ts %>%
  model(NNETAR(VIX))
fc4 <- fit4 %>%
  generate(times = 4, h = daysToForecast)
fc4 %>%
  autoplot(.sim) +
  autolayer((df_planetMood_ts %>% tail(100)), VIX) +
  theme(legend.position = "bottom")
# https://robjhyndman.com/hyndsight/nnetar-prediction-intervals/
VIX_forecasted <- as_tibble(fc4) %>% group_by(date) %>% summarise(pred_VIX = mean(.sim)) %>% pull(pred_VIX)
accuracy_pm_NNETAR <- calculateAccuracyDataframe_pm(VIX_forecasted)
accuracy_pm_NNETAR
sum(accuracy_pm_NNETAR$earningsPercent)
matplot(accuracy_pm_NNETAR[,c(2, 4:5)], type = "b", pch=1, col = c(1, 3,2))
legend("bottomleft", legend = c("VIX_txn", "VIX_real", "VIX_forecasted"), col= c(1, 3,2), pch=1)

# ------------------------------
# NEURAL NETWORKS WITH REGRESSORS
# Chapter 8 Neural Networks in Time Series Analysis
# https://bookdown.org/singh_pratap_tejendra/intro_time_series_r/neural-networks-in-time-series-analysis.html
library(forecast)
accuracies_all <- data.frame()
examplesToGenerate <- 10
sampleDates <- sort(sample(as_date(c(as_date("2021-01-01"):(max(df_planetMood$date)-lagToApply))), examplesToGenerate, replace=TRUE))
for (i in sampleDates) {
  # ----
  lastDateAvailable <- as_date("2022-06-01") # last date available for training observations
  print(paste0("Processing date: ", as_date(i)))
  lastDateAvailable <- as_date(i) # last date available for training observations
  firstDateToForecast <- lastDateAvailable + 1
  daysToForecast <- 7
  lagToApply <- daysToForecast
  lastDateToForecast <- firstDateToForecast + daysToForecast - 1
  # add a lagged columns to dataset:
  df_planetMood_1 <- df_planetMood %>% mutate(
    VIX_n = lag(VIX, n=lagToApply), 
    VVIX_n = lag(VVIX, n=lagToApply), 
    VIX3M_n = lag(VIX3M, n=lagToApply), 
    VIXNsdq_n = lag(VIXNsdq, n=lagToApply), 
    GoldVlty_n = lag(GoldVlty, n=lagToApply), 
    DAI3_n = lag(DAI3, n=lagToApply), 
    CCI_n = lag(CCI, n=lagToApply)
  ) %>% 
    filter(!is.na(VIX_n)) # we remove lines with NAs generated by lagging
  # prepare training dataset (past)
  df_planetMood_train <- df_planetMood_1 %>% 
    select(date, VIX, laggedVbles, calendarVbles) %>% 
    filter(date >= "2017-01-01" & date <= lastDateAvailable)
  # calculate regressors (future)
  futureData <- df_planetMood_1 %>% 
    select(date, laggedVbles, calendarVbles) %>% 
    filter(date >= firstDateToForecast & date <= lastDateToForecast)
  # ----
  # train
  yTrain <- df_planetMood_train$VIX
  xTrain <- df_planetMood_train[,3:13]  # remove date and VIX
  fit6 <- nnetar(ts(yTrain, frequency = 7), xreg = xTrain)
  # forecast
  xFuture <- futureData[,2:12] # remove date
  fc6 <- forecast(fit6, h = daysToForecast, xreg = xFuture, PI = F)
  # store
  VIX_forecasted <- fc6$mean
  accuracy_pm_NNETAR_xreg <- calculateAccuracyDataframe_pm(VIX_forecasted)
  matplot(accuracy_pm_NNETAR_xreg[,c(2, 4:5)], type = "b", pch=1, col = c(1, 3,2))
  legend("bottomleft", legend = c("VIX_txn", "VIX_real", "VIX_forecasted"), col= c(1, 3,2), pch=1)
  accuracies_all <- rbind(accuracies_all, accuracy_pm_NNETAR_xreg)
  class(accuracy_pm_NNETAR_xreg)
  # show
  accuracy_pm_NNETAR_xreg
}
print("Process finished")
accuracies_all
sum(accuracies_all$earningsPercent)
